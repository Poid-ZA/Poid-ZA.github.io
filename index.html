<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paddle Game</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React and ReactDOM CDN -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <!-- Babel for JSX -->
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.9/babel.min.js"></script>
</head>
<body class="min-h-screen flex items-center justify-center bg-gray-100">
  <div id="root"></div>
  <script type="text/babel">
    function GameCanvas() {
      const canvasRef = React.useRef(null);
      const [score, setScore] = React.useState(0);
      const [gameState, setGameState] = React.useState('playing'); // 'playing', 'won', 'lost'

      React.useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const paddleWidth = 100;
        const paddleHeight = 10;
        const ballRadius = 10;
        let paddleX = (canvas.width - paddleWidth) / 2;
        let ballX = canvas.width / 2;
        let ballY = canvas.height - 30;
        let ballDX = 4;
        let ballDY = -4;
        const brickRowCount = 5;
        const brickColumnCount = 8;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 30;
        const brickOffsetLeft = 30;
        let bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
          bricks[c] = [];
          for (let r = 0; r < brickRowCount; r++) {
            bricks[c][r] = { x: 0, y: 0, status: 1 };
          }
        }

        const drawPaddle = () => {
          ctx.beginPath();
          ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
          ctx.fillStyle = '#1E90FF';
          ctx.fill();
          ctx.closePath();
        };

        const drawBall = () => {
          ctx.beginPath();
          ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
          ctx.fillStyle = '#FF4500';
          ctx.fill();
          ctx.closePath();
        };

        const drawBricks = () => {
          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              if (bricks[c][r].status === 1) {
                const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                bricks[c][r].x = brickX;
                bricks[c][r].y = brickY;
                ctx.beginPath();
                ctx.rect(brickX, brickY, brickWidth, brickHeight);
                ctx.fillStyle = '#228B22';
                ctx.fill();
                ctx.closePath();
              }
            }
          }
        };

        const collisionDetection = () => {
          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              const b = bricks[c][r];
              if (b.status === 1) {
                if (
                  ballX > b.x &&
                  ballX < b.x + brickWidth &&
                  ballY > b.y &&
                  ballY < b.y + brickHeight
                ) {
                  ballDY = -ballDY;
                  b.status = 0;
                  setScore((prev) => prev + 1);
                  if (score + 1 === brickRowCount * brickColumnCount) {
                    setGameState('won');
                  }
                }
              }
            }
          }
        };

        const moveBall = () => {
          ballX += ballDX;
          ballY += ballDY;

          if (ballX + ballRadius > canvas.width || ballX - ballRadius < 0) {
            ballDX = -ballDX;
          }
          if (ballY - ballRadius < 0) {
            ballDY = -ballDY;
          } else if (ballY + ballRadius > canvas.height - paddleHeight) {
            if (ballX > paddleX && ballX < paddleX + paddleWidth) {
              ballDY = -ballDY;
            } else if (ballY + ballRadius > canvas.height) {
              setGameState('lost');
            }
          }
        };

        const draw = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawBricks();
          drawBall();
          drawPaddle();
          collisionDetection();
          moveBall();
        };

        const mouseMoveHandler = (e) => {
          const relativeX = e.clientX - canvas.offsetLeft;
          if (relativeX > 0 && relativeX < canvas.width) {
            paddleX = relativeX - paddleWidth / 2;
            if (paddleX < 0) paddleX = 0;
            if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
          }
        };

        canvas.addEventListener('mousemove', mouseMoveHandler);

        let animationFrameId;
        const gameLoop = () => {
          if (gameState === 'playing') {
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
          }
        };
        gameLoop();

        return () => {
          canvas.removeEventListener('mousemove', mouseMoveHandler);
          cancelAnimationFrame(animationFrameId);
        };
      }, [gameState, score]);

      const restartGame = () => {
        setScore(0);
        setGameState('playing');
        ballX = canvasRef.current.width / 2;
        ballY = canvasRef.current.height - 30;
        ballDX = 4;
        ballDY = -4;
      };

      return (
        <div className="flex flex-col items-center space-y-4">
          <h2 className="text-2xl font-bold">Score: {score}</h2>
          <canvas
            ref={canvasRef}
            width="800"
            height="400"
            className="border-2 border-gray-500"
          />
          {gameState !== 'playing' && (
            <div className="absolute flex flex-col items-center justify-center bg-black bg-opacity-50 w-full h-full">
              <h2 className="text-4xl font-bold text-white">
                {gameState === 'won' ? 'You Won!' : 'Game Over'}
              </h2>
              <button
                className="mt-4 px-6 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition"
                onClick={restartGame}
              >
                Restart
              </button>
            </div>
          )}
        </div>
      );
    }

    function App() {
      return (
        <div className="flex flex-col items-center p-6">
          <h1 className="text-4xl font-bold mb-6">Paddle Game</h1>
          <GameCanvas />
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
