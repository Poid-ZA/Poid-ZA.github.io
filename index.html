<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris Game</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React and ReactDOM CDN -->
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <!-- Babel for JSX -->
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.9/babel.min.js"></script>
</head>
<body class="min-h-screen flex items-center justify-center bg-gray-900 text-white">
  <div id="root"></div>
  <script type="text/babel">
    function TetrisCanvas() {
      const canvasRef = React.useRef(null);
      const [score, setScore] = React.useState(0);
      const [gameState, setGameState] = React.useState('playing'); // 'playing', 'gameover'

      React.useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const gridSize = 30;
        const cols = 10;
        const rows = 20;
        canvas.width = cols * gridSize;
        canvas.height = rows * gridSize;

        const colors = [
          null,
          '#FF0D72', // I
          '#0DC2FF', // O
          '#0DFF72', // T
          '#F538FF', // S
          '#FF8E0D', // Z
          '#FFE138', // J
          '#3877FF', // L
        ];

        const tetrominoes = {
          I: [[1, 1, 1, 1]],
          O: [[1, 1], [1, 1]],
          T: [[0, 1, 0], [1, 1, 1]],
          S: [[0, 1, 1], [1, 1, 0]],
          Z: [[1, 1, 0], [0, 1, 1]],
          J: [[1, 0, 0], [1, 1, 1]],
          L: [[0, 0, 1], [1, 1, 1]],
        };

        let board = Array(rows).fill().map(() => Array(cols).fill(0));
        let currentPiece = null;
        let pieceX = 0;
        let pieceY = 0;

        const createPiece = () => {
          const types = Object.keys(tetrominoes);
          const type = types[Math.floor(Math.random() * types.length)];
          return { shape: tetrominoes[type], color: colors[types.indexOf(type) + 1] };
        };

        const drawSquare = (x, y, color) => {
          ctx.fillStyle = color || '#333';
          ctx.fillRect(x * gridSize, y * gridSize, gridSize - 2, gridSize - 2);
          ctx.strokeStyle = '#555';
          ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
        };

        const drawBoard = () => {
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              drawSquare(c, r, board[r][c] ? colors[board[r][c]] : null);
            }
          }
        };

        const drawPiece = () => {
          if (currentPiece) {
            currentPiece.shape.forEach((row, y) => {
              row.forEach((value, x) => {
                if (value) {
                  drawSquare(pieceX + x, pieceY + y, currentPiece.color);
                }
              });
            });
          }
        };

        const collision = (x, y, piece) => {
          for (let r = 0; r < piece.shape.length; r++) {
            for (let c = 0; c < piece.shape[r].length; c++) {
              if (!piece.shape[r][c]) continue;
              const newX = x + c;
              const newY = y + r;
              if (newX < 0 || newX >= cols || newY >= rows) return true;
              if (newY < 0) continue;
              if (board[newY][newX]) return true;
            }
          }
          return false;
        };

        const mergePiece = () => {
          currentPiece.shape.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value) {
                board[pieceY + y][pieceX + x] = colors.indexOf(currentPiece.color);
              }
            });
          });
        };

        const clearLines = () => {
          let linesCleared = 0;
          for (let r = rows - 1; r >= 0; r--) {
            if (board[r].every(cell => cell)) {
              board.splice(r, 1);
              board.unshift(Array(cols).fill(0));
              linesCleared++;
              r++;
            }
          }
          if (linesCleared > 0) {
            setScore(prev => prev + linesCleared * 100);
          }
        };

        const rotatePiece = () => {
          const newShape = currentPiece.shape[0].map((_, i) =>
            currentPiece.shape.map(row => row[i]).reverse()
          );
          const tempPiece = { ...currentPiece, shape: newShape };
          if (!collision(pieceX, pieceY, tempPiece)) {
            currentPiece.shape = newShape;
          }
        };

        const movePiece = (dir) => {
          if (!collision(pieceX + dir, pieceY, currentPiece)) {
            pieceX += dir;
          }
        };

        const dropPiece = () => {
          if (!collision(pieceX, pieceY + 1, currentPiece)) {
            pieceY++;
          } else {
            mergePiece();
            clearLines();
            currentPiece = createPiece();
            pieceX = Math.floor(cols / 2) - Math.floor(currentPiece.shape[0].length / 2);
            pieceY = 0;
            if (collision(pieceX, pieceY, currentPiece)) {
              setGameState('gameover');
            }
          }
        };

        const hardDrop = () => {
          while (!collision(pieceX, pieceY + 1, currentPiece)) {
            pieceY++;
          }
          dropPiece();
        };

        const keyHandler = (e) => {
          if (gameState !== 'playing') return;
          if (e.key === 'ArrowLeft') movePiece(-1);
          if (e.key === 'ArrowRight') movePiece(1);
          if (e.key === 'ArrowDown') dropPiece();
          if (e.key === 'ArrowUp') rotatePiece();
          if (e.key === ' ') hardDrop();
        };

        document.addEventListener('keydown', keyHandler);

        let lastTime = 0;
        const dropInterval = 1000; // Drop every 1 second
        const gameLoop = (time) => {
          if (gameState !== 'playing') return;
          if (time - lastTime > dropInterval) {
            dropPiece();
            lastTime = time;
          }
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawBoard();
          drawPiece();
          requestAnimationFrame(gameLoop);
        };

        currentPiece = createPiece();
        pieceX = Math.floor(cols / 2) - Math.floor(currentPiece.shape[0].length / 2);
        pieceY = 0;
        requestAnimationFrame(gameLoop);

        return () => {
          document.removeEventListener('keydown', keyHandler);
        };
      }, [gameState]);

      const restartGame = () => {
        setScore(0);
        setGameState('playing');
      };

      return (
        <div className="flex flex-col items-center space-y-4">
          <h2 className="text-2xl font-bold">Score: {score}</h2>
          <canvas
            ref={canvasRef}
            className="border-2 border-gray-500"
          />
          {gameState === 'gameover' && (
            <div className="absolute flex flex-col items-center justify-center bg-black bg-opacity-50 w-full h-full">
              <h2 className="text-4xl font-bold text-white">Game Over</h2>
              <button
                className="mt-4 px-6 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition"
                onClick={restartGame}
              >
                Restart
              </button>
            </div>
          )}
        </div>
      );
    }

    function App() {
      return (
        <div className="flex flex-col items-center p-6">
          <h1 className="text-4xl font-bold mb-6">Tetris</h1>
          <div className="text-center mb-4">
            <p>Controls:</p>
            <p>←/→: Move | ↑: Rotate | ↓: Drop | Space: Hard Drop</p>
          </div>
          <TetrisCanvas />
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
